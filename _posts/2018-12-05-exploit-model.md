---
layout: post
title: Discussing Exploitation and Priv Escalation - Analysis of gvisor exploit
date: 2018-12-05
author: lumjjb
description: Discussing Exploitation and Priv Escalation - Analysis of gvisor exploit
---

In this blog post, we take a look at the work that Max Justicz wrote about in his article ["Privilege Escalation in gvisor, Google's Container Sandbox"](https://justi.cz/security/2018/11/14/gvisor-lpe.html).

We will discuss the threat model of gvisor and what the exploit provides. We will then discuss the differences between the LibOS security model between gvisor and Nabla containers - and go further to discuss other potential threats.

## Exploitation 102: Attacker capabilities

To understand a few concepts that we would like to talk about, let us go into a quick primer on how exploits are written and carried out. There are multiple reasons why an attacker would like to exploit an application. The most common reasons are that they want to leak some data from the application, or they want to be able to execute arbitrary code in the application (code exec).

Let's assume that we are exploiting an application (this could be something like redis or nginx) and we want to achieve arbitrary code execution (code exec).

Starting with our goal, we want to describe how an attacker derives an exploit - arbitrary code execution. How do we get arbitrary code execution? One way of doing that is by hijacking the control flow of the application. This can be done via various methods, like overwriting function pointers, overwriting an entry in the `.got` table, or taking advantage of architecture specific behaviors (like overwriting the return address in the stack used by the `ret` instruction), etc.


The main way of figuring out how to do this is by reverse engineering the application binary and finding bugs in the application. For example, a failure to check bounds may lead to a leak of stack data or heap data ([Heartbleed](http://heartbleed.com/)). And a use after free bug in memory allocation may be able to provide the ability to write to an arbitrary memory address. 

These type of bugs are too varied to identify and classify, which is why one way that we may think about them as *attacker capabilities* - what a bug gives us. For example, a use after free bug may provide us with an arbitrary write to any memory address (we call arb write for short), and the ability to leak some address information, we call a leak. 

These usually give us the ability to exploit more bugs - by learning about the location of where things are or by triggering code paths originally not reachable. 

For example, a leak counters [Address Space Layout Randomization (ASLR)](https://en.wikipedia.org/wiki/Address_space_layout_randomization)  by showing us the significant bits of the randomized address space. The ability to read pointers of two libc functions lets us derive the version of libc being used. The list goes on...

In general, with attacker capabilities to leak and arb write, it is almost a guarantee that we can get the capability to code exec. However, somtimes, we may only get limited versions of these abilities. For example, instead of arb read/write, we could only have limited read/write to a certain memory region.

Other examples of these are unreliable read/writes (does not always happen, depending on some randomness of the program), or read/writes that can include randomness or proximity. However, these type of limited capabilities can be overcome with additional work - performing actions more than once (rowhammer) or using certain techniques (i.e. heap spraying, nop slides).

## Explaining "Prvilege Escalation in gvisor"

```
+--------+ +--------+   +---------+
|  p1a   | |  p1a   |   |   p2a   |                      APP
+--------+ +--------+   +---------+
+-------------------+   +-------------------+
|      gvisor       |   |      gvisor       |            GVISOR
+-------------------+   +-------------------+
+--------------------------------------------------+
|                    kernel                        |     KERNEL
+--------------------------------------------------+
```

Before we jump into the exploit, let us look at how gvisor is used. Instances of gvisor can be created independent of each other with a shared kernel. For each gvisor instance, there can be one or more application processes running on them (i.e. `p1a`, `p1b`).

Now, let's take a look at [Max's work with gvisor](https://justi.cz/security/2018/11/14/gvisor-lpe.html). In his blog, he explains the bug that he has found in the gvisor implementation of the `shmctl` syscall, and an example of how he is able to perform targeted writes to a seperate process using the same gvisor userspace kernel.

The exploit assumes the following attacker capabilities: Code exec in an application process. This can be obtained via exploitation of the process `p1a` (i.e. redis/nginx). We annotate the diagram with attacker capabilities that an attacker has in parentheses.

```
+--------+ +--------+   +---------+
|  p1a   | |  p1b   |   |   p2a   |                      APP
| (code) | |        |   |         |                      
| (exec) | |        |   |         |                      
+--------+ +--------+   +---------+
+-------------------+   +-------------------+
|      gvisor       |   |      gvisor       |            GVISOR
+-------------------+   +-------------------+
+--------------------------------------------------+
|                    kernel                        |     KERNEL
+--------------------------------------------------+
```

The exploit abuses the `shmctl` bug to provide attacker capabilities to perform limited write to select memory region of which gvisor has access to. Max then uses this limited write capability to show that he has obtained capability of random writes to the adjacent application process `p1b` by attempting to write 'A's (`0x41`) with the limited write capabilities to the specific region/pages from the bug.

```
    +---WRITE--+
    |          |
    |          V
+--------+ +--------+   +---------+
|  p1a   | |  p1b   |   |   p2a   |                      APP
| (code) | |(random)|   |         |                      
| (exec) | |( write)|   |         |                      
+--------+ +--------+   +---------+
+-------------------+   +-------------------+
|      gvisor       |   |      gvisor       |            GVISOR
|  (limited write)  |   |                   |            
+-------------------+   +-------------------+
+--------------------------------------------------+
|                    kernel                        |     KERNEL
+--------------------------------------------------+
```

### Safe for now

We note that his proof of concept has shown random writes into an adjacent process on the same instance of gvisor. However, we note that to get the most out of gvisor isolation, one would want to have each process be on seperate gvisor instances. For just based on this proof of concept, there is no reason to panic today.

### Other implications

We note that this is one of many direction that Max has taken to build up his exploit - by showing random write into a adjacent application sharing the same gvisor instance. However, he mentions that for the limited write region in this bug:

>The backing memory is then reclaimed and handed to another (potentially more privileged) process.

This may perhaps lead to possibilities to obtain more attacker capabilities in the gvisor instance - maybe even code exec??? We'll discuss that in a later section of this post.


## Exploring differences in LibOS security model

Talk about differences in security model, gvisor trusts the libOS as part of the provider,

We don't trust the LibOS, even if the LibOS is fully exploited. what an attacker can do is the same as what he/she originally could do by running the application code.

```
+--------+ +--------+   +---------+
|  p1a   | |  p1a   |   |   p2a   |                      APP
+--------+ +--------+   +---------+
<<< 300 syscalls  >>>   <<< 300 syscalls  >>>
+-------------------+   +-------------------+
|      gvisor       |   |      gvisor       |            GVISOR
+-------------------+   +-------------------+
<<<  83 syscalls  >>>   <<<  83 syscalls  >>>
+--------------------------------------------------+
|                    kernel                        |     KERNEL
+--------------------------------------------------+
```


gvisor syscalls ~83
(https://github.com/google/gvisor/blob/0091db9cbddb6c9fb4c96fbde980780c98006eda/runsc/boot/filter/config.go)

```
+--------+ +--------+   +---------+
|  p1a   | |  p1a   |   |   p2a   |                      APP
+--------+ +--------+   +---------+
<<< 300 syscalls  >>>   <<< 300 syscalls  >>>
+-------------------+   +-------------------+
|      nabla        |   |      nabla        |            GVISOR
+-------------------+   +-------------------+
<<<   7 syscalls  >>>   <<<   7 syscalls  >>>
+--------------------------------------------------+
|                    kernel                        |     KERNEL
+--------------------------------------------------+
```


nabla syscalls 7

## But it's a memory safe langauge!

Talk about memory safety and stuff here - and the implications of code exec.

http://codearcana.com/posts/2013/04/23/exploiting-a-go-binary.html
